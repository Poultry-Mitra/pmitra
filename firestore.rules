/**
 * @fileoverview Firestore Security Rules for PoultryMitra application.
 *
 * Core Philosophy:
 * This ruleset employs a strict user-ownership model for user profiles and farm data.
 * It leverages existence-based authorization for admin roles and enforces dealer-only
 * access to supplier information. Data validation focuses primarily on relational
 * integrity and authorization, while minimizing schema enforcement to allow for
 * rapid prototyping.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information.
 * - /roles_admin/{userId}: Presence of a document indicates admin privileges.
 * - /farms/{farmId}: Stores farm information.
 * - /farms/{farmId}/farmData/{farmDataId}: Stores time-series farm data.
 * - /farms/{farmId}/alerts/{alertId}: Stores farm alerts.
 * - /subscriptionPlans/{subscriptionPlanId}: Stores subscription plan details.
 * - /orders/{orderId}: Stores order information, linking farmers and dealers.
 * - /suppliers/{supplierId}: Stores supplier information, specific to each dealer.
 *
 * Key Security Decisions:
 * - User profiles are only accessible to the owning user.
 * - Admin privileges are granted based on document existence in /roles_admin/{userId}.
 * - Farm data and alerts are restricted to the farm owner (user who owns the farm profile).
 * - Subscription plans are publicly readable but not writable by clients.
 * - Orders are accessible to either the farmer or the dealer involved.
 * - Supplier information is managed exclusively by the owning dealer.
 * - List operations are generally restricted to owners of user-scoped subcollections.
 *
 * Denormalization for Authorization:
 * The rules assume that userId and farmId are denormalized into documents to avoid costly get() operations.
 *
 * Structural Segregation:
 * The application uses separate collections for user profiles and admin roles, which
 * improves security and performance compared to using a single collection with a boolean flag.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) User with matching UID can create their own profile.
     * @allow (get, list, update, delete) Only the user with matching UID can access their profile.
     * @deny (create) User cannot create a profile with a mismatched UID.
     * @deny (update, delete) User cannot modify or delete another user's profile.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to admin role documents.
     * @path /roles_admin/{userId}
     * @allow (create) Anyone can create an admin role document.  This is for prototyping ONLY.  In production, restrict to server-side.
     * @allow (get) Anyone can read admin role documents.
     * @allow (list) List operation is denied.
     * @deny (update, delete) Only an existing admin can update or delete.
     * @principle Uses existence in this collection as proof of admin role.
     */
    match /roles_admin/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isAdmin() {
          return get(/databases/$(database)/documents/roles_admin/$(request.auth.uid)).data != null;
      }

      allow get: if true;
      allow list: if false;
      allow create: if true; // TODO: Restrict to server-side only.  Anyone can make themselves an admin in this prototype.
      allow update: if isSignedIn() && isAdmin() && request.auth.uid == userId;
      allow delete: if isSignedIn() && isAdmin() && request.auth.uid == userId;
    }

    /**
     * @description Controls access to farm documents.
     * @path /farms/{farmId}
     * @allow (create) Anyone can create a farm.  For prototyping only.  A proper implementation would link this to user creation.
     * @allow (get, list) Anyone can read farm documents.
     * @deny (update, delete) Only the owner of the farm can modify or delete it.
     * @principle Enforces ownership for updates and deletes.
     */
    match /farms/{farmId} {
      function isSignedIn() {
        return request.auth != null;
      }

      // For simplicity in this prototype, we are going to assume the farmId is also stored within the UserProfile.
      function isFarmOwner(farmId) {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.farmId == farmId;
      }

      function isExistingFarmOwner(farmId) {
        return isFarmOwner(farmId) && resource.data != null;
      }

      allow get, list: if true;
      allow create: if true;  //TODO: Tie to user creation in production.
      allow update: if isSignedIn() && isExistingFarmOwner(farmId);
      allow delete: if isSignedIn() && isExistingFarmOwner(farmId);
    }

    /**
     * @description Controls access to farm data documents under a specific farm.
     * @path /farms/{farmId}/farmData/{farmDataId}
     * @allow (create) Only the farm owner can create farm data.
     * @allow (get, list) Anyone can read farm data.
     * @deny (update, delete) Only the farm owner can modify or delete farm data.
     * @principle Restricts write access to the farm owner.
     */
    match /farms/{farmId}/farmData/{farmDataId} {
      function isSignedIn() {
        return request.auth != null;
      }

      // For simplicity in this prototype, we are going to assume the farmId is also stored within the UserProfile.
      function isFarmOwner(farmId) {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.farmId == farmId;
      }

      function isExistingFarmOwner(farmId) {
        return isFarmOwner(farmId) && resource.data != null;
      }


      allow get, list: if true;
      allow create: if isSignedIn() && isFarmOwner(farmId);
      allow update: if isSignedIn() && isExistingFarmOwner(farmId);
      allow delete: if isSignedIn() && isExistingFarmOwner(farmId);
    }

    /**
     * @description Controls access to farm alert documents under a specific farm.
     * @path /farms/{farmId}/alerts/{alertId}
     * @allow (create) Only the farm owner can create farm alerts.
     * @allow (get, list) Anyone can read farm alerts.
     * @deny (update, delete) Only the farm owner can modify or delete farm alerts.
     * @principle Restricts write access to the farm owner.
     */
    match /farms/{farmId}/alerts/{alertId} {
      function isSignedIn() {
        return request.auth != null;
      }

      // For simplicity in this prototype, we are going to assume the farmId is also stored within the UserProfile.
      function isFarmOwner(farmId) {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.farmId == farmId;
      }
       function isExistingFarmOwner(farmId) {
        return isFarmOwner(farmId) && resource.data != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isFarmOwner(farmId);
      allow update: if isSignedIn() && isExistingFarmOwner(farmId);
      allow delete: if isSignedIn() && isExistingFarmOwner(farmId);
    }

    /**
     * @description Controls access to subscription plan documents.
     * @path /subscriptionPlans/{subscriptionPlanId}
     * @allow (get, list) Anyone can read subscription plan documents.
     * @deny (create, update, delete) No client-side writes allowed.
     * @principle Allows public read access but restricts writes.
     */
    match /subscriptionPlans/{subscriptionPlanId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to order documents.
     * @path /orders/{orderId}
     * @allow (get, list) Farmer or Dealer involved in the order can read it.
     * @deny (create, update, delete) Only the farmer or dealer involved in the order can create, update, or delete it.
     * @principle Restricts access to parties involved in the order.
     */
    match /orders/{orderId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isFarmerOrDealer(orderId) {
        return (get(/databases/$(database)/documents/orders/$(orderId)).data.farmerId == request.auth.uid)
            || (get(/databases/$(database)/documents/orders/$(orderId)).data.dealerId == request.auth.uid);
      }

      function isExistingFarmerOrDealer(orderId) {
        return isSignedIn() && isFarmerOrDealer(orderId) && resource.data != null;
      }


      allow get: if isSignedIn() && isFarmerOrDealer(orderId);
      allow list: if false; // Listing is not allowed in this prototype, but should probably be allowed for the farmer/dealer.
      allow create: if isSignedIn() && (request.resource.data.farmerId == request.auth.uid || request.resource.data.dealerId == request.auth.uid);
      allow update: if isSignedIn() && isExistingFarmerOrDealer(orderId);
      allow delete: if isSignedIn() && isExistingFarmerOrDealer(orderId);
    }

    /**
     * @description Controls access to supplier documents.
     * @path /suppliers/{supplierId}
     * @allow (create, get, list, update, delete) Only the dealer who owns the supplier can manage it.
     * @principle Enforces dealer-ownership for supplier data.
     */
    match /suppliers/{supplierId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isDealer(supplierId) {
        return get(/databases/$(database)/documents/suppliers/$(supplierId)).data.dealerUID == request.auth.uid;
      }

      function isExistingDealer(supplierId) {
        return isSignedIn() && isDealer(supplierId) && resource.data != null;
      }


      allow get: if isSignedIn() && isDealer(supplierId);
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.dealerUID == request.auth.uid;
      allow update: if isSignedIn() && isExistingDealer(supplierId);
      allow delete: if isSignedIn() && isExistingDealer(supplierId);
    }
  }
}