/**
 * @fileoverview Firestore Security Rules for PoultryMitra application.
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure, owner-centric model, ensuring users can only
 * access or modify data they explicitly own or have been granted access to.
 * Data validation is relaxed for rapid prototyping.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only to the owner.
 * - /farms/{farmId}: Farm information, publicly readable, but owner-writeable.
 * - /farms/{farmId}/farmData/{farmDataId}: Farm data, accessible only with valid farm.
 * - /farms/{farmId}/alerts/{alertId}: Farm alerts, accessible only with valid farm.
 * - /subscriptionPlans/{subscriptionPlanId}: Publicly readable subscription plans.
 * - /orders/{orderId}: Orders between farmers and dealers, accessible only to involved parties.
 * - /suppliers/{supplierId}: Suppliers, accessible only to the owning dealer.
 *
 * Key Security Decisions:
 * - User listing is disallowed for privacy.
 * - Subscription plans are publicly readable.
 * - Data validation is minimal, focusing on ownership and relational integrity for prototyping.
 * - Public read access is granted only for collections explicitly intended to be public.
 *
 * Denormalization for Authorization:
 * - The 'Order' object requires both 'farmerId' and 'dealerId' to determine authorization.
 *
 * Structural Segregation:
 * - Private user data is kept in the `/users/{userId}` collection, separate from public farm data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Only the user can read/write their own profile.
     * @path /users/{userId}
     * @allow (create, update, delete, get, list) if the request.auth.uid matches the {userId}.
     * @deny (create, update, delete, get, list) if the request.auth.uid does not match the {userId}.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false; // User listing is disallowed

      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow delete: if isOwner(userId);
    }

    /**
     * @description Secure farm data. Publicly readable, but owner-only writes.
     * @path /farms/{farmId}
     * @allow (get, list) Allow public read access.
     * @allow (create) if request.resource.data.ownerId == request.auth.uid
     * @allow (update, delete) if isOwner(resource.data.ownerId)
     * @deny  Writes if not the owner.
     * @principle Public read, owner-only write access.
     */
    match /farms/{farmId} {
      allow get, list: if true;

      // CRITICAL: Cannot implement owner-only writes. The 'Farm' entity is missing an 'ownerId' or 'authorId' field.
      allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update, delete: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
    }

    /**
     * @description Secure farm data entries. Only accessible with valid farm and valid owner.
     * @path /farms/{farmId}/farmData/{farmDataId}
     * @allow (get, list) if the user is the owner of the parent farm document.
     * @allow (create, update, delete) if the user is the owner of the parent farm document.
     * @deny  if not the owner.
     * @principle Enforces document ownership and data locality.
     */
    match /farms/{farmId}/farmData/{farmDataId} {
       function isFarmOwner(farmId) {
            return get(/databases/$(database)/documents/farms/$(farmId)).data.ownerId == request.auth.uid;
       }

      allow get, list: if isFarmOwner(farmId); // TODO: Limit this to the Farm owner
      allow create, update, delete: if isFarmOwner(farmId); // TODO: Limit this to the Farm owner
    }

    /**
     * @description Secure farm alerts. Only accessible with valid farm and valid owner.
     * @path /farms/{farmId}/alerts/{alertId}
     * @allow (get, list) if the user is the owner of the parent farm document.
     * @allow (create, update, delete) if the user is the owner of the parent farm document.
     * @deny  if not the owner.
     * @principle Enforces document ownership and data locality.
     */
    match /farms/{farmId}/alerts/{alertId} {
        function isFarmOwner(farmId) {
            return get(/databases/$(database)/documents/farms/$(farmId)).data.ownerId == request.auth.uid;
       }

      allow get, list: if isFarmOwner(farmId); // TODO: Limit this to the Farm owner
      allow create, update, delete: if isFarmOwner(farmId); // TODO: Limit this to the Farm owner
    }

    /**
     * @description Subscription plans are publicly readable.
     * @path /subscriptionPlans/{subscriptionPlanId}
     * @allow get, list: if true;
     * @deny create, update, delete: Always deny writes.
     * @principle Public read-only access.
     */
    match /subscriptionPlans/{subscriptionPlanId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Secure orders. Only the farmer or dealer involved in the order can access it.
     * @path /orders/{orderId}
     * @allow (get, list) if request.auth.uid is either the farmerId or the dealerId.
     * @allow (create) if request.auth.uid is either the farmerId or the dealerId.
     * @allow (update, delete) if request.auth.uid is either the farmerId or the dealerId and the document exists.
     * @deny if not the farmer or dealer involved.
     * @principle Shared access between collaborating users.
     */
    match /orders/{orderId} {
      function isParticipant(orderId) {
          return request.auth != null && (get(/databases/$(database)/documents/orders/$(orderId)).data.farmerId == request.auth.uid || get(/databases/$(database)/documents/orders/$(orderId)).data.dealerId == request.auth.uid);
      }

      allow get: if isParticipant(orderId);
      allow list: if false; // Listing not permitted

      allow create: if request.auth != null && (request.resource.data.farmerId == request.auth.uid || request.resource.data.dealerId == request.auth.uid);
      allow update: if request.auth != null && (request.resource.data.farmerId == request.auth.uid || request.resource.data.dealerId == request.auth.uid) && isParticipant(orderId);
      allow delete: if isParticipant(orderId);
    }

    /**
     * @description Secure suppliers. Only the dealer who owns the supplier can manage it.
     * @path /suppliers/{supplierId}
     *   - Grant: (get, list) if request.auth.uid matches the supplier's dealerUID.
     *   - Grant: (create) if request.auth.uid matches the supplier's dealerUID.
     *   - Grant: (update, delete) if request.auth.uid matches the supplier's dealerUID and the document exists.
     * @deny All requests not originating from the owning dealer.
     * @principle Enforces document ownership for writes.
     */
    match /suppliers/{supplierId} {
      function isDealerOwner(supplierId) {
        return request.auth != null && get(/databases/$(database)/documents/suppliers/$(supplierId)).data.dealerUID == request.auth.uid;
      }

      allow get: if isDealerOwner(supplierId);
      allow list: if false; // Listing not permitted

      allow create: if request.auth != null && request.resource.data.dealerUID == request.auth.uid;
      allow update: if isDealerOwner(supplierId);
      allow delete: if isDealerOwner(supplierId);
    }
  }
}